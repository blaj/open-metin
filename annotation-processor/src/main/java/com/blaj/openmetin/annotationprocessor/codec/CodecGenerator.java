package com.blaj.openmetin.annotationprocessor.codec;

import com.blaj.openmetin.annotationprocessor.codec.utils.FieldContextUtils;
import com.blaj.openmetin.contracts.annotation.PacketHeader;
import com.blaj.openmetin.contracts.enums.PacketDirection;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.ParameterizedTypeName;
import com.palantir.javapoet.TypeSpec;
import java.io.IOException;
import java.util.List;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic.Kind;

public class CodecGenerator {

  private static final ClassName byteBufClassName = ClassName.get("io.netty.buffer", "ByteBuf");
  private static final ClassName serviceAnnotationClassName =
      ClassName.get("org.springframework.stereotype", "Service");
  private static final ClassName generatedAnnotationClassName =
      ClassName.get("lombok", "Generated");
  private static final ClassName packetDecoderInterfaceClassName =
      ClassName.get("com.blaj.openmetin.shared.common.abstractions", "PacketDecoderService");
  private static final ClassName packetEncoderInterfaceClassName =
      ClassName.get("com.blaj.openmetin.shared.common.abstractions", "PacketEncoderService");

  private final ProcessingEnvironment processingEnvironment;
  private final FieldCodecStrategyFactory fieldCodecStrategyFactory;
  private final TypeChecker typeChecker;
  private final Filer filer;
  private final Messager messager;

  public CodecGenerator(
      ProcessingEnvironment processingEnvironment,
      FieldCodecStrategyFactory fieldCodecStrategyFactory) {
    this.processingEnvironment = processingEnvironment;
    this.fieldCodecStrategyFactory = fieldCodecStrategyFactory;
    this.typeChecker = new TypeChecker(processingEnvironment);
    this.filer = processingEnvironment.getFiler();
    this.messager = processingEnvironment.getMessager();
  }

  public void generate(TypeElement typeElement) throws IOException {
    var packageName =
        processingEnvironment
            .getElementUtils()
            .getPackageOf(typeElement)
            .getQualifiedName()
            .toString();
    var packetClassName = typeElement.getSimpleName().toString();
    var packetClass = ClassName.get(packageName, packetClassName);

    var header = typeElement.getAnnotation(PacketHeader.class);
    var fields =
        FieldContextUtils.extractFieldContexts(
            typeElement, packetClass, 0, typeChecker, processingEnvironment);

    generateDecoder(packageName, packetClassName, packetClass, header, fields);
    generateEncoder(packageName, packetClassName, packetClass, header, fields);
  }

  private void generateDecoder(
      String packageName,
      String packetClassName,
      ClassName packetClass,
      PacketHeader header,
      List<FieldContext> fields)
      throws IOException {

    String decoderClassName = packetClassName + "DecoderService";

    var decodeMethodBuilder =
        MethodSpec.methodBuilder("decode")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .addParameter(byteBufClassName, "in")
            .returns(packetClass)
            .addStatement("var packet = new $T()", packetClass);

    for (var field : fields) {
      var fieldCodecStrategy = fieldCodecStrategyFactory.get(field);
      fieldCodecStrategy.generateDecodingMethod(decodeMethodBuilder, field);
    }

    if (header.isSequence()) {
      decodeMethodBuilder.addStatement("in.skipBytes(1)");
    }

    decodeMethodBuilder.addStatement("return packet");

    var decoderClass =
        TypeSpec.classBuilder(decoderClassName)
            .addAnnotation(serviceAnnotationClassName)
            .addAnnotation(generatedAnnotationClassName)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addSuperinterface(
                ParameterizedTypeName.get(packetDecoderInterfaceClassName, packetClass))
            .addJavadoc("Generated decoder for {@link $L}\n", packetClassName)
            .addMethod(createGetHeaderMethod(header))
            .addMethod(createGetDirectionMethod(header))
            .addMethod(decodeMethodBuilder.build())
            .build();

    JavaFile.builder(packageName, decoderClass)
        .addFileComment("AUTO-GENERATED by GeneratePacketCodecProcessor - DO NOT EDIT")
        .indent("  ")
        .build()
        .writeTo(filer);

    messager.printMessage(Kind.NOTE, "Generated decoder: " + packageName + "." + decoderClassName);
  }

  private void generateEncoder(
      String packageName,
      String packetClassName,
      ClassName packetClass,
      PacketHeader header,
      List<FieldContext> fields)
      throws IOException {
    var encoderClassName = packetClassName + "EncoderService";

    var encodeMethodBuilder =
        MethodSpec.methodBuilder("encode")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .addParameter(packetClass, "packet")
            .addParameter(byteBufClassName, "out");

    for (var field : fields) {
      var fieldCodecStrategy = fieldCodecStrategyFactory.get(field);
      fieldCodecStrategy.generateEncodingMethod(encodeMethodBuilder, field);
    }

    if (header.isSequence()) {
      encodeMethodBuilder.addStatement("out.writeByte(0)");
    }

    var getPacketClassMethod =
        MethodSpec.methodBuilder("getPacketClass")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .returns(ParameterizedTypeName.get(ClassName.get(Class.class), packetClass))
            .addStatement("return $T.class", packetClass)
            .build();

    var encoderClass =
        TypeSpec.classBuilder(encoderClassName)
            .addAnnotation(serviceAnnotationClassName)
            .addAnnotation(generatedAnnotationClassName)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addSuperinterface(
                ParameterizedTypeName.get(packetEncoderInterfaceClassName, packetClass))
            .addJavadoc("Generated encoder for {@link $L}\n", packetClassName)
            .addJavadoc(
                "<p>Header: 0x$L, Direction: $L\n",
                String.format("%02X", header.header()),
                header.direction())
            .addJavadoc("<p><strong>This class is auto-generated. Do not modify!</strong>\n")
            .addMethod(createGetHeaderMethod(header))
            .addMethod(getPacketClassMethod)
            .addMethod(encodeMethodBuilder.build())
            .build();

    JavaFile.builder(packageName, encoderClass)
        .addFileComment("AUTO-GENERATED by GeneratePacketCodecProcessor - DO NOT EDIT")
        .indent("  ")
        .build()
        .writeTo(filer);

    messager.printMessage(Kind.NOTE, "Generated encoder: " + packageName + "." + encoderClassName);
  }

  private MethodSpec createGetHeaderMethod(PacketHeader header) {
    return MethodSpec.methodBuilder("getHeader")
        .addModifiers(Modifier.PUBLIC)
        .addAnnotation(Override.class)
        .returns(int.class)
        .addStatement("return 0x$L", String.format("%02X", header.header()))
        .build();
  }

  private MethodSpec createGetDirectionMethod(PacketHeader header) {
    return MethodSpec.methodBuilder("getDirection")
        .addModifiers(Modifier.PUBLIC)
        .addAnnotation(Override.class)
        .returns(PacketDirection.class)
        .addStatement("return $T.$L", PacketDirection.class, header.direction().name())
        .build();
  }
}
