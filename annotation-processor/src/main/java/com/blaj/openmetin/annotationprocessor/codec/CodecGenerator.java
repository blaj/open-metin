package com.blaj.openmetin.annotationprocessor.codec;

import com.blaj.openmetin.annotationprocessor.codec.utils.FieldContextUtils;
import com.blaj.openmetin.contracts.annotation.PacketHeader;
import com.blaj.openmetin.contracts.enums.PacketDirection;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.ParameterizedTypeName;
import com.palantir.javapoet.TypeSpec;
import java.io.IOException;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic.Kind;

public class CodecGenerator {

  private static final ClassName byteBufClassName = ClassName.get("io.netty.buffer", "ByteBuf");
  private static final ClassName serviceAnnotationClassName =
      ClassName.get("org.springframework.stereotype", "Service");
  private static final ClassName generatedAnnotationClassName =
      ClassName.get("lombok", "Generated");
  private static final ClassName packetDecoderInterfaceClassName =
      ClassName.get("com.blaj.openmetin.shared.common.abstractions", "PacketDecoderService");
  private static final ClassName packetEncoderInterfaceClassName =
      ClassName.get("com.blaj.openmetin.shared.common.abstractions", "PacketEncoderService");

  private final ProcessingEnvironment processingEnvironment;
  private final FieldCodecStrategyFactory fieldCodecStrategyFactory;
  private final TypeChecker typeChecker;
  private final Filer filer;
  private final Messager messager;

  public CodecGenerator(
      ProcessingEnvironment processingEnvironment,
      FieldCodecStrategyFactory fieldCodecStrategyFactory) {
    this.processingEnvironment = processingEnvironment;
    this.fieldCodecStrategyFactory = fieldCodecStrategyFactory;
    this.typeChecker = new TypeChecker(processingEnvironment);
    this.filer = processingEnvironment.getFiler();
    this.messager = processingEnvironment.getMessager();
  }

  public void generate(TypeElement typeElement) throws IOException {
    var packageName =
        processingEnvironment
            .getElementUtils()
            .getPackageOf(typeElement)
            .getQualifiedName()
            .toString();
    var packetClassName = typeElement.getSimpleName().toString();
    var packetClass = ClassName.get(packageName, packetClassName);

    var header = typeElement.getAnnotation(PacketHeader.class);
    var fields =
        FieldContextUtils.extractFieldContexts(
            typeElement, packetClass, 0, typeChecker, processingEnvironment);

    generateDecoder(packageName, packetClassName, packetClass, header, fields);
    generateEncoder(packageName, packetClassName, packetClass, header, fields);
  }

  private void generateDecoder(
      String packageName,
      String packetClassName,
      ClassName packetClass,
      PacketHeader header,
      List<FieldContext> fields)
      throws IOException {
    if (!Set.of(header.direction()).contains(PacketDirection.INCOMING)) {
      return;
    }

    String decoderClassName = packetClassName + "DecoderService";

    var decodeMethodBuilder =
        MethodSpec.methodBuilder("decode")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .addParameter(byteBufClassName, "in")
            .returns(packetClass)
            .addStatement("var packet = new $T()", packetClass);

    for (var field : fields) {
      var fieldCodecStrategy = fieldCodecStrategyFactory.get(field);
      fieldCodecStrategy.generateDecodingMethod(decodeMethodBuilder, field);
    }

    if (header.isSequence()) {
      decodeMethodBuilder.addStatement("in.skipBytes(1)");
    }

    decodeMethodBuilder.addStatement("return packet");

    var decoderClass =
        TypeSpec.classBuilder(decoderClassName)
            .addAnnotation(serviceAnnotationClassName)
            .addAnnotation(generatedAnnotationClassName)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addSuperinterface(
                ParameterizedTypeName.get(packetDecoderInterfaceClassName, packetClass))
            .addJavadoc("Generated decoder for {@link $L}\n", packetClassName)
            .addMethod(createGetHeaderMethod(header))
            .addMethod(createGetDirectionMethod(header))
            .addMethod(decodeMethodBuilder.build())
            .build();

    JavaFile.builder(packageName, decoderClass)
        .addFileComment("AUTO-GENERATED by GeneratePacketCodecProcessor - DO NOT EDIT")
        .indent("  ")
        .build()
        .writeTo(filer);

    messager.printMessage(Kind.NOTE, "Generated decoder: " + packageName + "." + decoderClassName);
  }

  private void generateEncoder(
      String packageName,
      String packetClassName,
      ClassName packetClass,
      PacketHeader header,
      List<FieldContext> fields)
      throws IOException {
    if (!Set.of(header.direction()).contains(PacketDirection.OUTGOING)) {
      return;
    }

    var encoderClassName = packetClassName + "EncoderService";

    var encodeMethodBuilder =
        MethodSpec.methodBuilder("encode")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .addParameter(packetClass, "packet")
            .addParameter(byteBufClassName, "out");

    for (var field : fields) {
      var fieldCodecStrategy = fieldCodecStrategyFactory.get(field);
      fieldCodecStrategy.generateEncodingMethod(encodeMethodBuilder, field);
    }

    if (header.isSequence()) {
      encodeMethodBuilder.addStatement("out.writeByte(0)");
    }

    var getPacketClassMethod =
        MethodSpec.methodBuilder("getPacketClass")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .returns(ParameterizedTypeName.get(ClassName.get(Class.class), packetClass))
            .addStatement("return $T.class", packetClass)
            .build();

    var encoderClass =
        TypeSpec.classBuilder(encoderClassName)
            .addAnnotation(serviceAnnotationClassName)
            .addAnnotation(generatedAnnotationClassName)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addSuperinterface(
                ParameterizedTypeName.get(packetEncoderInterfaceClassName, packetClass))
            .addJavadoc("Generated encoder for {@link $L}\n", packetClassName)
            .addJavadoc(
                "<p>Header: 0x$L, Direction: $L\n",
                String.format("%02X", header.header()),
                header.direction())
            .addJavadoc("<p><strong>This class is auto-generated. Do not modify!</strong>\n")
            .addMethod(createGetHeaderMethod(header))
            .addMethod(getPacketClassMethod)
            .addMethod(encodeMethodBuilder.build())
            .build();

    JavaFile.builder(packageName, encoderClass)
        .addFileComment("AUTO-GENERATED by GeneratePacketCodecProcessor - DO NOT EDIT")
        .indent("  ")
        .build()
        .writeTo(filer);

    messager.printMessage(Kind.NOTE, "Generated encoder: " + packageName + "." + encoderClassName);
  }

  private MethodSpec createGetHeaderMethod(PacketHeader header) {
    return MethodSpec.methodBuilder("getHeader")
        .addModifiers(Modifier.PUBLIC)
        .addAnnotation(Override.class)
        .returns(int.class)
        .addStatement("return 0x$L", String.format("%02X", header.header()))
        .build();
  }

  private MethodSpec createGetDirectionMethod(PacketHeader header) {
    var returnType =
        ParameterizedTypeName.get(ClassName.get(Set.class), ClassName.get(PacketDirection.class));

    var methodBuilder =
        MethodSpec.methodBuilder("getDirection")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .returns(returnType);

    var directions = header.direction();

    if (directions.length == 0) {
      methodBuilder.addStatement(
          "return $T.noneOf($T.class)", EnumSet.class, PacketDirection.class);
    } else {
      var enumValues =
          Arrays.stream(directions).map(d -> "$T." + d.name()).collect(Collectors.joining(", "));

      var args = new Object[directions.length + 1];
      args[0] = EnumSet.class;
      for (int i = 0; i < directions.length; i++) {
        args[i + 1] = PacketDirection.class;
      }

      methodBuilder.addStatement("return $T.of(" + enumValues + ")", args);
    }

    return methodBuilder.build();
  }
}
